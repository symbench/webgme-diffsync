/*globals define, WebGMEGlobal*/
/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Mon Sep 19 2022 18:43:02 GMT-0500 (Central Daylight Time).
 */


define([
    'js/Constants',
    'webgme-json-importer/JSONImporter',
    'webgme-diffsync/WJIDiffSync',
    'js/Utils/GMEConcepts',
    'js/NodePropertyNames',
    'webgme-diffsync/DemoDiffSyncUtils',
    'underscore'
], function (
    CONSTANTS,
    JSONImporter,
    DiffSyncUtils,
    GMEConcepts,
    nodePropertyNames,
    Utils,
    _
) {

    'use strict';
    const WJIDiffSync = DiffSyncUtils.default;
    const {NodeDiffFactory, SaveTask} = Utils;
    class DemoDiffSyncControl {
        constructor(options) {
            this._logger = options.logger.fork('Control');

            this._client = options.client;
            this.synchronizer = null;
            // Initialize core collections and variables
            this._initializeWidgets(options.widgets);

            this._currentNodeId = null;
            this._currentNodeParentId = undefined;
            this.pendingSave = null;

            this._initWidgetEventHandlers();

            this._logger.debug('ctor finished');
        }

        _initializeWidgets(widgets) {
            const [serverStateWidget, commonShadowWidget, clientStateWidget] = widgets;

            this.serverStateWidget = serverStateWidget;
            this.commonShadowWidget = commonShadowWidget;
            this.clientStateWidget = clientStateWidget;
            this.serverStateWidget.$el.css('width', '30%');
            this.commonShadowWidget.$el.css('width', '30%');
            this.clientStateWidget.$el.css('width', '35%'); // More width because editable


            serverStateWidget.setTitle('Server State');
            commonShadowWidget.setTitle('Common Shadow');
            clientStateWidget.setTitle('Client State');
        }

        _initWidgetEventHandlers = function () {
            const onChange = async (updated, previous, /*error, patch*/) => {
                if (!_.isEmpty(previous.json) && this.synchronizer) {
                    const {project, rootNode, core} = await this.getCoreInstance();
                    if (this.pendingSave) {
                        this.pendingSave.cancel();
                    }
                    const saveTask = new SaveTask(
                        this.synchronizer,
                        project,
                        this._client.getActiveBranchName(),
                        this._client.getActiveCommitHash()
                    );

                    this.pendingSave = saveTask;
                    await this.pendingSave.save(this._currentNodeId, updated.json);
                    if (this.pendingSave === saveTask) {
                        this.pendingSave = null;
                    }
                    const importer = new JSONImporter(core, rootNode);
                    const node = await core.loadByPath(rootNode, this._currentNodeId);
                    this.setWidgetsState(['server', 'shadow', 'client'], node, importer);

                }
            };

            this.clientStateWidget.setOnChange(_.debounce(onChange.bind(this), 750));
        };

        async getCoreInstance() {
            return await new Promise((resolve, reject) => this._client.getCoreInstance(null, (err, result) => err ? reject(err) : resolve(result)));
        }

        async setStateFromNode(nodeId) {
            const {core, rootNode} = await this.getCoreInstance();
            const importer = new JSONImporter(core, rootNode);
            const node = await core.loadByPath(rootNode, nodeId);
            const nodeJSON = await importer.toJSON(node);
            const parent = core.getParent(node);
            if(!this.synchronizer) {
                const diffFunction = NodeDiffFactory(core.getPath(parent));
                this.synchronizer = new WJIDiffSync(
                    node,
                    nodeJSON,
                    nodeJSON,
                    importer,
                    diffFunction
                );
                this.setWidgetsState(null, node, importer);
            } else {
                await this.synchronizer.onUpdatesFromServer(node);
                this.setWidgetsState(null, node, importer);
            }

        }

        setWidgetsState(widgets=null, node, importer) {
            if(!this.synchronizer) return;
            if(!widgets) {
                widgets = ['client', 'shadow', 'server'];
            }

            if (widgets.includes('server')) {
                importer.toJSON(node).then(json => {
                    this.serverStateWidget.setState({json}, true);
                });
            }

            if (widgets.includes('client')) {
                this.clientStateWidget.setState(
                    {json: this.synchronizer.clientState},
                    false
                );
            }

            if(widgets.includes('shadow')) {
                this.commonShadowWidget.setState(
                    {json: this.synchronizer.shadow},
                    true
                );
            }
        }

        selectedObjectChanged(nodeId) {
            this._logger.debug('activeObject nodeId \'' + nodeId + '\'');

            // Remove current territory patterns
            if (this._territoryId) {
                this._client.removeUI(this._territoryId);
                this._territoryId = null;
            }

            if (nodeId !== this._currentNodeId) {
                this.synchronizer = null;
            }

            this._currentNodeId = nodeId;
            if (typeof this._currentNodeId === 'string') {

                // Put new node's info into territory rules
                this._selfPatterns = {};
                // TODO: Will this work? I can't remember tbh...
                this._selfPatterns[nodeId] = {children: Infinity};  // Territory "rule"

                this._territoryId = this._client.addUI(this, async () => {
                    this.setStateFromNode(nodeId);
                });
                this._client.updateTerritory(this._territoryId, this._selfPatterns);
            }
        }

        _stateActiveObjectChanged(model, activeObjectId) {
            if (this._currentNodeId === activeObjectId) {
                // The same node selected as before - do not trigger
            } else {
                this.selectedObjectChanged(activeObjectId);
            }
        }

        _getObjectDescriptor(/*nodeId*/) {
            return {};
        }

        /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
        destroy() {
            this._detachClientEventListeners();
        }

        _attachClientEventListeners() {
            this._detachClientEventListeners();
            WebGMEGlobal.State.on('change:' + CONSTANTS.STATE_ACTIVE_OBJECT, this._stateActiveObjectChanged, this);
        }

        _detachClientEventListeners() {
            WebGMEGlobal.State.off('change:' + CONSTANTS.STATE_ACTIVE_OBJECT, this._stateActiveObjectChanged);
        }

        onActivate() {
            this._attachClientEventListeners();
            if (typeof this._currentNodeId === 'string') {
                WebGMEGlobal.State.registerActiveObject(this._currentNodeId, {suppressVisualizerFromNode: true});
            }
        }

        onDeactivate() {
            this._detachClientEventListeners();
        }
    }

    return DemoDiffSyncControl;
});
